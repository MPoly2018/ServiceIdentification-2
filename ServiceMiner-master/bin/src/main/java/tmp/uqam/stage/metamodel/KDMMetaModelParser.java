package tmp.uqam.stage.metamodel.kdmparser;

import org.apache.lucene.index.CorruptIndexException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.gmt.modisco.omg.kdm.action.ActionElement;
import org.eclipse.gmt.modisco.omg.kdm.action.BlockUnit;
import org.eclipse.gmt.modisco.omg.kdm.action.Calls;
import org.eclipse.gmt.modisco.omg.kdm.action.ExceptionUnit;
import org.eclipse.gmt.modisco.omg.kdm.code.*;
import org.eclipse.gmt.modisco.omg.kdm.code.Package;
import org.eclipse.gmt.modisco.omg.kdm.code.impl.CodeModelImpl;
import org.eclipse.gmt.modisco.omg.kdm.kdm.KDMModel;
import org.eclipse.gmt.modisco.omg.kdm.kdm.KdmPackage;
import org.eclipse.gmt.modisco.omg.kdm.kdm.Segment;
import org.eclipse.gmt.modisco.omg.kdm.action.TryUnit;
import org.jdom2.*;
import org.jdom2.input.SAXBuilder;

import de.linguatools.disco.Compositionality;
import de.linguatools.disco.CorruptConfigFileException;
import de.linguatools.disco.DISCO;
import de.linguatools.disco.DISCO.SimilarityMeasure;
import de.linguatools.disco.DenseMatrix;
import de.linguatools.disco.ReturnDataCol;
import de.linguatools.disco.WrongWordspaceTypeException;
import tmp.uqam.stage.MinSpanningTree.BaseCoupling;
import tmp.uqam.stage.MinSpanningTree.Component;
import tmp.uqam.stage.metamodel.*;
import tmp.uqam.stage.slicing.ClassType;
import tmp.uqam.stage.slicing.ClassVertex;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.io.*;


/**
 * A parser for a kdm xmi file generated by the MoDisco Eclipse plugin
 */
public class KDMMetaModelParser extends MetaModelParser {

	private Resource resource;
	private CodeModel model;
	private List<Datatype> allSources;
	private Map<String, ClassVertex> classes;
	public LinkMap linkMap;
	public Map<String,Metrics> Class_Metrics ;

	public Map<String, Metrics> getClass_Metrics() {
		return Class_Metrics;
	}
	public void setClass_Metrics(Map<String, Metrics> class_Metrics) {
		Class_Metrics = class_Metrics;
	}
	public void setClasses(Map<String, ClassVertex> classes) {
		this.classes = classes;
	}
	public KDMMetaModelParser(String kdmLocation, String modelName, boolean resource) {
		super(kdmLocation, resource);
		URI uri = URI.createFileURI(file.getPath());
		model = loadModelFromKDM(uri, modelName);
		classes = new HashMap<>();
		linkMap = new LinkMap();
		allSources = getAllSources();
		Class_Metrics = new HashMap<>();
	}
	private CodeModel loadModelFromKDM(URI uri, String modelName) {
		KdmPackage.eINSTANCE.eClass();

		Resource.Factory.Registry reg = Resource.Factory.Registry.INSTANCE;
		reg.getExtensionToFactoryMap().put("xmi", new XMIResourceFactoryImpl());
		ResourceSet resourceSet = new ResourceSetImpl();
		this.resource = resourceSet.getResource(uri, true);

		Segment segment = (Segment) resource.getContents().get(0);
		for (KDMModel kdmModel : segment.getModel()) {
			if (kdmModel.getName().compareTo(modelName) == 0) return (CodeModel) kdmModel;
		}
		throw new KDMModelNotFoundException(modelName);
	}

	/**
	 * Resolve all relations between classes from the model and add them to the linkmap
	 */
	private void getStaticRelationsAndCalls() {
		for (Datatype d : allSources) {
			resolveContainmentRelations(d);
			resolveHierarchicalRelations(d);
		}
		Logger.getLogger(getClass().getName()).log(Level.INFO, "Relations : " + linkMap.size());
	}

	/**
	 * Resolve containment between classes, the basic uml arrow
	 * add them to the internal linkmap
	 */
	private void resolveContainmentRelations(Datatype d) {
		for (CodeItem item : GenericClassUnit.getCodeElements(d)) {
			if (item instanceof StorableUnit) {
				StorableUnit storableUnit = (StorableUnit) item;
				if (allSources.contains(storableUnit.getType())) {
					linkMap.put(new Link(classes.get(d.getName()), classes.get(storableUnit.getType().getName())), LinkType.ONEWAY);
				}
				if (storableUnit.getType() instanceof TemplateType && !storableUnit.getType().getCodeRelation().isEmpty()) {
					Datatype dt = (Datatype) storableUnit.getType().getCodeRelation().get(0).getTo();
					if (allSources.contains(dt)) {
						linkMap.put(new Link(classes.get(d.getName()), classes.get(dt.getName())), LinkType.ONEWAY);
					}

				}
			}
		}
	}

	/**
	 * Resolve inheritance between components (extends and implements)
	 * add them to the internal linkmap
	 */
	private void resolveHierarchicalRelations(Datatype datatype) {
		for (AbstractCodeRelationship relation : datatype.getCodeRelation()) {
			if (relation instanceof Implements && allSources.contains(relation.getTo())) {
				linkMap.put(new Link(classes.get(datatype.getName()), classes.get(relation.getTo().getName())), LinkType.IMPLEMENTS);

			}
			if (relation instanceof Extends && allSources.contains(relation.getTo())) {
				linkMap.put(new Link(classes.get(datatype.getName()), classes.get(relation.getTo().getName())), LinkType.EXTENDS);
			}
		}
	}

	/**
	 * Get the caller method of a call as a controlelement to be queries
	 */
	private ControlElement getCallerMethod(Calls call) {
		EObject current = call;
		while (current.eContainer() != null) {
			current = current.eContainer();
			if (current instanceof ControlElement) {
				return (ControlElement) current;
			}
		}
		return null;
	}

	/**
	 * Get the code model of the project
	 */
	private CodeModel getCodeModel(AbstractCodeElement elt) {
		if (elt == null) return null;
		EObject current = elt;
		while (current.eContainer() != null) {
			current = current.eContainer();
			if (current instanceof CodeModel) {
				return (CodeModel) current;
			}
		}
		return null;
	}

	/**
	 * Get all generic class unit that are part of the model that is currently analyzed and not
	 * from a library or java
	 */
	private List<Datatype> getAllSources() {
		List<Datatype> sources = new ArrayList<>();
		for (AbstractCodeElement elem : model.getCodeElement()) {
			explorePackages(elem, sources);
		}
		Logger.getLogger(getClass().getName()).log(Level.INFO, "Sources : " + sources.size());
		return sources;
	}

	/**
	 * Recursively explore packages to get all the sources in the project
	 */
	private void explorePackages(AbstractCodeElement elem, List<Datatype> sources) {
		if (elem instanceof Package) {
			for (Object e : ((Package) elem).getCodeElement()) {
				explorePackages((AbstractCodeElement) e, sources);
			}
		} else if (GenericClassUnit.isGenericClassUnit(elem)) {
			sources.add((Datatype) elem);
		}
	}

	/**
	 * Get all calls which are made between source elements
	 * adds their dependencies to the linkmap with two types possible :
	 * method invocation or constructor invocation
	 */
	private void getSourceCalls() {
		int callsCount = 0;
		List<Calls> callsList = getAllCalls();

		for (Calls call : callsList) {
			ActionElement action = (ActionElement) call.eContainer();

			if (call.getTo()==null ) {
				continue;
			}
			else if(call.getTo().eContainer() instanceof CodeModelImpl) {
				continue;
			}


			Datatype toClass = (Datatype) call.getTo().eContainer();
			ControlElement fromMethod = getCallerMethod(call);
			if (fromMethod == null) continue;
			Datatype fromClass = (Datatype) fromMethod.eContainer();

			if (getCodeModel(call.getFrom()) == this.model && getCodeModel(call.getTo()) == this.model) {
				callsCount++;
				Logger.getLogger(getClass().getName()).log(Level.INFO, "---MethodCalls : From " + call.getFrom().getName() + "------>  To " +call.getTo());

				ClassVertex classVertexFrom = classes.get(fromClass.getName());
				ClassVertex classVertexTo = classes.get(toClass.getName());
				if (classVertexFrom != null && classVertexTo != null) {
					if (action.getKind().contains("creation")) {
						linkMap.put(new Link(classes.get(fromClass.getName()), classes.get(toClass.getName())), LinkType.CONSTRUCTOR_INVOKE);
					} else if (action.getKind().contains("method")) {
						linkMap.put(new Link(classes.get(fromClass.getName()), classes.get(toClass.getName())), LinkType.METHOD_INVOKE);
					}
				}
			}
		}
		Logger.getLogger(getClass().getName()).log(Level.INFO, "Calls : " + callsCount);
	}

	/**
	 * Get all the calls found in the project
	 */
	private List<Calls> getAllCalls() {
		List<Calls> callsList = new ArrayList<>();
		for (Iterator<EObject> i = resource.getAllContents(); i.hasNext(); ) {
			Object obj = i.next();
			if (obj instanceof Calls) {
				callsList.add((Calls) obj);
			}
		}
		return callsList;
	}


	/**
	 * Get all the TryUnits found in the source code
	 */
	private List<TryUnit> getAllTryUnits() {
		List<TryUnit> TryList = new ArrayList<>();
		for (Iterator<EObject> i = resource.getAllContents(); i.hasNext(); ) {
			Object obj = i.next();
			if (obj instanceof TryUnit) {
				TryList.add((TryUnit) obj);
			}
		}
		return TryList;
	}

	private List<ActionElement> getall_if_switch_units(){
		List<ActionElement> IfList = new ArrayList<>();
		for (Iterator<EObject> i = resource.getAllContents(); i.hasNext(); ) {
			Object obj = i.next();
			if (obj instanceof BlockUnit ) {
				BlockUnit bloc = (BlockUnit)obj; 
				if (bloc.eContainer() instanceof ActionElement ) {

					ActionElement action = (ActionElement) bloc.eContainer();
					String name=action.getName();

					if ( name != null ) {
						if (name.equals("if")){
							//System.out.println("MMMfffffMMMMMMMMMMMMMMMMMMMMMMMM"+ action.getName());
							IfList.add(action);
						}

					}

				}
			}
		}
		return IfList;

	}

	private void CalculateNumberofIfPerclass(Map<String,Metrics>ClassesIf){

		List<ActionElement> IfList = new ArrayList<>();
		IfList=getall_if_switch_units();

		Metrics index=new Metrics();
		String CalssNameContaintingIf ;
		for(ActionElement ifs: IfList){

			CalssNameContaintingIf= getFQN2(ifs);
			if (CalssNameContaintingIf!=null){
				index= ClassesIf.get(CalssNameContaintingIf);
				if (index!=null){
					if(!ClassesIf.containsKey(CalssNameContaintingIf)) {
						index.number_if=1;

					}
					else {
						index.number_if= index.number_if+1;	
					}
					ClassesIf.put(CalssNameContaintingIf,index);
				}
			}
		}


	}

	/**
	 * Get the number of methods for each source element of the project
	 */
	private Map<String, Integer> getNumberOfMethodFromSources() {
		Map<String, Integer> classesMethods = new HashMap<>();
		for (Datatype dt : allSources) {
			int cpt = 0;
			for (CodeItem item : GenericClassUnit.getCodeElements(dt)) {
				if (item instanceof MethodUnit) {
					cpt++;
				}
			}
			classesMethods.put(dt.getName(), cpt);

			System.out.println("******888888 Class: "+dt.getName());
		}
		return classesMethods;
	}

	/**
	 * Get class types from the list of sources
	 */
	private Map<String, ClassType> getTypeFromSources() {
		Map<String, ClassType> classesType = new HashMap<>();
		for (Datatype dt : allSources) {
			if (dt instanceof InterfaceUnit) {
				classesType.put(dt.getName(), ClassType.INTERFACE);
			}
			if (dt instanceof EnumeratedType) {
				classesType.put(dt.getName(), ClassType.ENUM);
			}
			if (dt instanceof ClassUnit) {
				try {
					if (((ClassUnit) dt).getIsAbstract()) {
						classesType.put(dt.getName(), ClassType.ABSTRACT_CLASS);
					} else {
						classesType.put(dt.getName(), ClassType.CLASS);
					}
				}
				//Sometimes it bugs and abstract is null...
				catch (NullPointerException npe) {
					classesType.put(dt.getName(), ClassType.CLASS);
				}
			}
		}
		return classesType;
	}

	@Override
	public MetaModel extractMetaModel() {

		/* 
    	try {
			diso() ;
		} catch (CorruptIndexException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (CorruptConfigFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 */


		allSources.forEach(datatype -> classes.put(datatype.getName(), new ClassVertex(datatype.getName())));
		allSources.forEach(datatype -> Logger.getLogger(getClass().getName()).log(Level.INFO, datatype.getClass().getName()));
		getStaticRelationsAndCalls();
		getSourceCalls();



/*
		

//        printAllCalls(); 		//Added by Manel
        //List<MethodUnit> methods = getAllMethods(); //Added by Manel
        List<MethodUnit> methods = getListOfMethodFromSources(); //Added by Manel
        List<Calls> callsList = getAllCalls();

        Class_Metrics=CalculateFan_In_Out_OfMethod2(methods, callsList);
        ///Class_Metrics.forEach((key, value) -> System.out.println(key + "::: number of fanin:" + value.fanin + "::: number of fanout:" + value.fanout));//Added by Manel

        Calculation_of_all_fanInOut();//Added by Manel


        //Map<String,Integer> Calss_MunberTryCatch = new HashMap<>(); //Added by Manel

        CalculateTryCatchByClass(Class_Metrics); //Added by Manel 
        //Class_Metrics.forEach((key, value) -> System.out.println(key + "::: number of try:" + value.number_try));//Added by Manel

        //getall_if_switch_units();
        Calculation_of_SQL_Queries(Class_Metrics);
        Class_Metrics.forEach((key, value) -> System.out.println(key + "::: number of SQL queries:" + value.number_transactions));//Added by Manel


        CalculateNumberofIfPerclass(Class_Metrics) ;//Added by Manel
		 
*/

		Fill_class_metrics_from_file("Compiere_metrics_by_class");
		Class_Metrics.forEach((key, value) -> System.out.println("class;" + key +";fanin;" + value.fanin + ";fanout;" + value.fanout+ ";if;" + value.number_if + ";try;" + value.number_try+ ";SQL queries;" + value.number_transactions+ "McCabe complexity;"+value.McCabe));//Added by Manel



		getNumberOfMethodFromSources().forEach((name, nbMethods) -> classes.get(name).setNbMethods(nbMethods));
		getTypeFromSources().forEach((name, type) -> classes.get(name).setClassType(type));
		return new MetaModel(linkMap.migrateAndComputeLinks(), new HashSet<>(classes.values()));
	}

	public Set<ClassVertex> getClasses() {
		return new HashSet<>(classes.values());
	}

	public LinkMap getLinkMap() {
		return linkMap;
	}




	/**
	 * 
	 * Added By Manel
	 * Get all calls which are made between source elements
	 * adds their dependencies to the linkmap with two types possible :
	 * method invocation or constructor invocation
	 */
	private void getSourceCalls2() {
		int callsCount = 0;
		List<Calls> callsList = getAllCalls();

		for (Calls call : callsList) {
			ActionElement action = (ActionElement) call.eContainer();
			if (call.getTo().eContainer() instanceof CodeModelImpl) {
				continue;
			}

			Datatype toClass = (Datatype) call.getTo().eContainer();
			ControlElement fromMethod = getCallerMethod(call);
			if (fromMethod == null) continue;
			Datatype fromClass = (Datatype) fromMethod.eContainer();

			if (getCodeModel(call.getFrom()) == this.model && getCodeModel(call.getTo()) == this.model) {
				callsCount++;
				//Logger.getLogger(getClass().getName()).log(Level.INFO, "---MethodCalls : From " + call.getFrom() + "------>  To " + call.getTo());
				ClassVertex classVertexFrom = classes.get(fromClass.getName());
				ClassVertex classVertexTo = classes.get(toClass.getName());
				if (classVertexFrom != null && classVertexTo != null) {
					if (action.getKind().contains("creation")) {
						linkMap.put(new Link(classes.get(fromClass.getName()), classes.get(toClass.getName())), LinkType.CONSTRUCTOR_INVOKE);
					} else if (action.getKind().contains("method")) {
						linkMap.put(new Link(classes.get(fromClass.getName()), classes.get(toClass.getName())), LinkType.METHOD_INVOKE);
					}
				}
			}
		}
		Logger.getLogger(getClass().getName()).log(Level.INFO, "Calls : " + callsCount);
	}


	public void printAllCalls(){
		int callsCount = 0;
		List<Calls> callsList = getAllCalls();

		for(Calls call: callsList){
			boolean ignored = false;
			ControlElement toMethod = call.getTo();
			Datatype toClass = (Datatype)toMethod.eContainer();
			ControlElement fromMethod = getCallerMethod(call);
			Datatype fromClass = null;
			if(fromMethod!=null) fromClass = (Datatype)fromMethod.eContainer();

			if(getCodeModel(call.getFrom())!=this.model ||
					getCodeModel(call.getTo())!=this.model){
				ignored = true;
			}
			System.out.println("("+callsCount+") Call: " +
					(fromClass!=null?fromClass.getName():"?------?") + "." +
					(fromMethod!=null?fromMethod.getName():"?------?") + "->" +
					toClass.getName() + "." + 
					toMethod.getName());
			System.out.println((ignored?"************":"")+getFQN(fromMethod)+"->"+getFQN(toMethod));

			callsCount++;
		}
		for(Iterator<EObject> i = resource.getAllContents(); i.hasNext() ; ){
			Object obj = i.next();

			if(obj instanceof Calls){

			}
		}
		System.out.println("****** Total Calls: "+callsCount);
	}


	private String getFQN(AbstractCodeElement elt){
		if(elt==null) return "??";
		EObject current = elt;
		String fqn = elt.getName();
		while(current.eContainer()!=null){
			current = current.eContainer();
			if(current instanceof ClassUnit || 
					current instanceof InterfaceUnit ||
					current instanceof MethodUnit || 
					current instanceof org.eclipse.gmt.modisco.omg.kdm.code.Package || 
					current instanceof Module){
				CodeItem codeItem = (CodeItem)current;
				fqn=codeItem.getName()+"."+fqn;
			}
		}
		return fqn;
	}
	
	
	//manel
	private String getFQNClass(AbstractCodeElement elt){
		if(elt==null) return "??";
		EObject current = elt;
		String fqn = elt.getName();
		while(current.eContainer()!=null){
			current = current.eContainer();
			if(current instanceof ClassUnit || 
					current instanceof InterfaceUnit){
				CodeItem codeItem = (CodeItem)current;
				fqn=codeItem.getName()+"."+fqn;
			}
		}
		return fqn;
	}

	private String getFQN_without_method(AbstractCodeElement elt){
		if(elt==null) return "??";
		EObject current = elt;
		String Name_Of_Abstract_Element = elt.getName();
		////System.out.println("naaaaaaaaame method ==="+Name_Of_Abstract_Element);
		if (Name_Of_Abstract_Element==null) return Name_Of_Abstract_Element;
		String fqn = Name_Of_Abstract_Element;
		while(current.eContainer()!=null){
			current = current.eContainer();
			if(current instanceof ClassUnit || 
					current instanceof InterfaceUnit ||
					current instanceof MethodUnit || 
					current instanceof org.eclipse.gmt.modisco.omg.kdm.code.Package || 
					current instanceof Module){
				CodeItem codeItem = (CodeItem)current;
				if (!(current instanceof MethodUnit)){

					fqn=codeItem.getName()+"."+fqn;
				}

			}
		}
		if (fqn.indexOf(Name_Of_Abstract_Element)==0) return null;
		return (String) fqn.subSequence(0, fqn.indexOf(Name_Of_Abstract_Element)-1);
	}







	public List<MethodUnit> getAllMethods(){

		List<MethodUnit> methodsList = new ArrayList<MethodUnit>();

		for(Iterator<EObject>i = resource.getAllContents(); i.hasNext();){	
			Object obj = i.next();
			if (obj instanceof MethodUnit){
				MethodUnit method = (MethodUnit) obj;
				methodsList.add(method);

				//System.out.println(getFQN(method));
			}		
		}
		return methodsList;

	}


	/**
	 * Get the list of methods for each source element of the project
	 */
	private List<MethodUnit> getListOfMethodFromSources() {
		List<MethodUnit> methodsList = new ArrayList<MethodUnit>();
		for (Datatype dt : allSources) {
			int cpt = 0;


			for (CodeItem item : GenericClassUnit.getCodeElements(dt)) {
				if (item instanceof MethodUnit) {
					MethodUnit method = (MethodUnit) item;
					if (!methodsList.contains(method)) methodsList.add(method);

					System.out.println("--------------Method Added: " +getFQN(method));
				}
			}      
		}
		return methodsList;
	}

	private List<MethodUnit> EliminateDuplicationfromList(List<MethodUnit> methodsList) {


		return methodsList;
	}

	private String getFQN2(AbstractCodeElement elt){
		if(elt==null) return "??";
		EObject current = elt;
		String fqn = elt.getName();


		while(current.eContainer()!=null){
			current = current.eContainer();
			if(current instanceof ClassUnit || 
					current instanceof InterfaceUnit ||
					current instanceof org.eclipse.gmt.modisco.omg.kdm.code.Package || 
					current instanceof Module){
				CodeItem codeItem = (CodeItem)current;

				fqn=codeItem.getName()+"."+fqn;

			}
		}
		int index = fqn.lastIndexOf(".");
		if (index>0){ 
			fqn= fqn.substring(0,index);
		}
		else 
		{
			fqn=null;
		}


		return fqn;
	}


	//pas suuure!
	public void  CalculateTryCatchByClass( Map<String,Metrics> Calss_MunberTryCatch ){

		List<TryUnit> TryList = getAllTryUnits();

		//Map<String,Integer> Calss_MunberTryCatch = new HashMap<>();

		String CalssNameContaintingTry ;
		for(TryUnit trys: TryList){

			CalssNameContaintingTry= getFQN2(trys);
			if (CalssNameContaintingTry!=null){	
				Metrics metrique = new Metrics(); 
				if(Calss_MunberTryCatch.containsKey(CalssNameContaintingTry)) {

					metrique=Calss_MunberTryCatch.get(CalssNameContaintingTry);
					metrique.number_try=metrique.number_try+1;
					Calss_MunberTryCatch.put(CalssNameContaintingTry,metrique);
				}

			}
		}

	}


	/*
    public Map<String,Integer> CalculateTryCatchByClass(){
    	List<TryUnit> TryList = getAllTryUnits();

    	Map<String,Integer> Calss_MunberTryCatch = new HashMap<>();


    	for(TryUnit trys: TryList){

    		System.out.println("--=========Try--------"+TryList.size()+"====="+trys.getClass().toString()) ;
    		Calss_MunberTryCatch.put("Manel",1 );

    	}

    	return Calss_MunberTryCatch;

    }
	 */

	public Map<Integer,Integer> CalculateFan_In_Out_OfMethod(MethodUnit method,List<Calls> callsList){

		Map<Integer, Integer> Fan_in_out = new HashMap<>();


		int Fan_in=0;
		int Fan_out=0 ;
		int callsCount = 0;

		for(Calls call: callsList){
			boolean ignored = false;
			ControlElement toMethod = call.getTo();
			if (toMethod!=null){
				Datatype toClass = (Datatype)toMethod.eContainer();
				ControlElement fromMethod = getCallerMethod(call);
				Datatype fromClass = null;

				if(fromMethod!=null) fromClass = (Datatype)fromMethod.eContainer();

				if(getCodeModel(call.getFrom())!=this.model ||
						getCodeModel(call.getTo())!=this.model){
					ignored = true;
				}
				//System.out.println("("+callsCount+") Call: " +
				//		(fromClass!=null?fromClass.getName():"?------?") + "." +
				//		(fromMethod!=null?fromMethod.getName():"?------?") + "->" +
				//		toClass.getName() + "." + 
				//		toMethod.getName());
				//System.out.println((ignored?"************":"")+getFQN(fromMethod)+"->"+getFQN(toMethod));



				if(   getFQN(method).equals(getFQN(fromMethod))  ) Fan_out++;

				if(   getFQN(method).equals(getFQN(toMethod))  ) Fan_in++;			



				callsCount++;
			}
		}
		//Logger.getLogger(getClass().getName()).log(Level.INFO, "****** Method: "+getFQN(method) +"  Fan_in= "+Fan_in+"  Fan_out="+Fan_out);
		System.out.println("****** Method: "+getFQN(method) +"  Fan_in= "+Fan_in+"  Fan_out="+Fan_out);


		Fan_in_out.put(Fan_in,Fan_out);


		return Fan_in_out ;

	}



	public Map<String,Metrics> CalculateFan_In_Out_OfMethod2(List<MethodUnit> methods,List<Calls> callsList){

		Map<String, Metrics> Fan_in_out = new HashMap<>();


		int Fan_in=0;
		int Fan_out=0 ;
		int callsCount = 0;




		for (MethodUnit method: methods){	
			Fan_in=0;
			Fan_out=0 ;

			for(Calls call: callsList){

				ControlElement toMethod = call.getTo();
				if (toMethod!=null) {Datatype toClass = (Datatype)toMethod.eContainer();}
				ControlElement fromMethod = getCallerMethod(call);
				Datatype fromClass = null;

				if(fromMethod!=null) fromClass = (Datatype)fromMethod.eContainer();

				if(   getFQN(method).equals(getFQN(fromMethod))  ) Fan_out++;			
				if(   getFQN(method).equals(getFQN(toMethod))  ) Fan_in++;			



			}
			callsCount++;

			String ClassName= getFQN_without_method(method);
			//Logger.getLogger(getClass().getName()).log(Level.INFO, "****** Method: "+getFQN(method) +"  Fan_in= "+Fan_in+"  Fan_out="+Fan_out);
			//System.out.println("****** Classss Faninout: "+ ClassName );
			if (ClassName!=null){
				Metrics faninout= new Metrics(Fan_in, Fan_out);	
				if (Fan_in_out.containsKey(ClassName)){
					faninout.fanin= Fan_in+ Fan_in_out.get(ClassName).fanin;
					faninout.fanout= Fan_out+ Fan_in_out.get(ClassName).fanout;

					//System.out.println("******"+callsCount+"method-----"+getFQN(method)+"----- Class:fanin " +getFQN_without_method(method));
				}
				Fan_in_out.put(ClassName, faninout );
			}
		}

		return Fan_in_out ;

	}


	public void Update_fanin_fanout_of_a_cluster(Component service) {
		int Fan_in=0;
		int Fan_out=0 ;

		String FromClassName = null; 
		String ToClassName = null;


		List<Calls> callsList = getAllCalls();


		for(Calls call: callsList){



			ControlElement toMethod = call.getTo();
			if (toMethod!=null) {


				Datatype toClass = (Datatype)toMethod.eContainer();

				ControlElement fromMethod = getCallerMethod(call);
				Datatype fromClass = null;

				if(fromMethod!=null) fromClass = (Datatype)fromMethod.eContainer();

				FromClassName = getFQNClass(fromClass);
				
				ToClassName = getFQNClass(toClass);
				
				
			}

			if (service.Service_contain_class_name(FromClassName) & !service.Service_contain_class_name(ToClassName) ) {


				service.Fanout++;

				

			} else if  (!service.Service_contain_class_name(FromClassName) & service.Service_contain_class_name(ToClassName) ) {

				service.FanIn++;
				

			}



		}


	}

	public void Calculation_of_all_fanInOut2(){


		List<MethodUnit> methodsList = new ArrayList<MethodUnit>();

		methodsList= getListOfMethodFromSources();

		List<Calls> callsList = getAllCalls();

		Map<Integer, Integer> Fan_in_out = new HashMap<>();

		for (MethodUnit method: methodsList ){

			Fan_in_out= CalculateFan_In_Out_OfMethod(method, callsList);

		}

	}


	public void Calculation_of_SQL_Queries(Map<String,Metrics> Class_metrics){

		SAXBuilder sxb = new SAXBuilder();
		Document document= new Document();
		Element racine = new Element("Queries");

		try
		{
			//On crée un nouveau document JDOM avec en argument le fichier XML
		
			document = sxb.build(new File("base-queries.xml"));
			
			//document = sxb.build(new File("serverApps-queries.xml"));
			
			
			//document = sxb.build(new File("serverRoot-queries.xml"));
		}
		catch(Exception e){

			System.out.println("-----------file not found XML");
		}

		//On initialise un nouvel élément racine avec l'élément racine du document.
		racine = document.getRootElement();

		List<Element> listEtudiants = racine.getChildren("Query");
		Iterator<Element> i = listEtudiants.iterator();

		String ClassName;
		while(i.hasNext())
		{

			Element courant = (Element)i.next();

			ClassName=courant.getChild("ExecClass").getText().replace("/", ".");
			ClassName= ClassName.replaceFirst(".", "");
			ClassName= ClassName.replaceFirst(".java", "");

			System.out.println("-----------Class name XML  " +ClassName);
			Metrics metric = new Metrics();
			metric=Class_metrics.get(ClassName);
			if (metric!=null){
				metric.increment_NUM_SQL_Queries(1);  
				Class_metrics.put(ClassName, metric);
			}
			else{

				System.out.println("-------Metric null");
			}

		}


	}


	public void Calculation_of_all_fanInOut(){


		List<MethodUnit> methodsList = new ArrayList<MethodUnit>();

		methodsList= getListOfMethodFromSources();

		List<Calls> callsList = getAllCalls();

		Map<Integer, Integer> Fan_in_out = new HashMap<>();

		for (MethodUnit method: methodsList ){

			Fan_in_out= CalculateFan_In_Out_OfMethod(method, callsList);


		}

	}
	public void diso() throws CorruptIndexException, FileNotFoundException, IOException, CorruptConfigFileException{


		DISCO disco = DISCO.load("cc.en.300-COL.denseMatrix");
		float sim = disco.semanticSimilarity("shopping", "product", DISCO.getVectorSimilarity(SimilarityMeasure.COSINE));
		System.out.println("++++++++++++++++++++++++++++++++++++++++++similarity between 'Haus' and 'Häuschen': "+sim);
		// get word vector for "Haus" as map
		Map<String,Float> wordVectorHaus = disco.getWordvector("shopping");
		// get word embedding for "Haus" as float array
		float[] wordEmbeddingHaus = ((DenseMatrix) disco).getWordEmbedding("shopping");
		// solve analogy x is to "Frau" as "König" is to "Mann"
		try {
			List<ReturnDataCol> result = Compositionality.solveAnalogy("bride", "groom", "child", disco);
		} catch (WrongWordspaceTypeException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
	}


	public void Fill_class_metrics_from_file(String FileName) {




		try (BufferedReader br = new BufferedReader(new FileReader(FileName))) {
			String line;
			Integer i=0;
			while ((line = br.readLine()) != null) {
				String[] values = line.split(";");
				i++;

				Metrics The_metric= new Metrics(Integer.parseInt(values[2]),Integer.parseInt(values[4]), Integer.parseInt(values[6]), Integer.parseInt(values[8]),Integer.parseInt(values[10]));
				Class_Metrics.put(values[0], The_metric);

			}

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	
	
	public void Fill_McCabe_metrics_from_file(String FileName, Map<String,Metrics> Class_Metrics2) {




		try (BufferedReader br = new BufferedReader(new FileReader(FileName))) {
			String line;
			Integer i=0;
			while ((line = br.readLine()) != null) {
				String[] values = line.split(";");
				String ClassNamee=null;
				i++;
				int lastIndexOfdot = values[1].lastIndexOf(".");
				
				if (lastIndexOfdot>0) {
					ClassNamee= values[1].substring(lastIndexOfdot);
					} else {
						ClassNamee= values[1];
						
					}
				int McCabe = Integer.parseInt(values[2]);
				
				Metrics The_metric= Class_Metrics2.get(ClassNamee); 
				
				if (The_metric!=null) {
					
					The_metric.McCabe = McCabe;
					
					Class_Metrics2.put(ClassNamee, The_metric);
					
				}

				
			}

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	

}